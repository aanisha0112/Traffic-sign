# Traffic Sign Alert System

A Flask web application that recognizes traffic sign images, provides safety guidance in multiple languages, and generates spoken alerts (MP3) using gTTS. The app loads a pre-trained TensorFlow model (HDF5) to classify traffic sign images and returns the predicted sign, confidence, top-3 alternatives, a short guidance message, and base64-encoded audio for immediate playback.

This README describes the project from start to finish: how it works, how to set it up, how to run it, how to retrain the model, and common troubleshooting tips.

Table of contents
- Project overview
- Features
- Project structure
- Requirements
- Quick start (run locally)
- Usage (web UI + API)
- How predictions work
- Supported languages
- Training / Retraining the model (high-level)
- Improving accuracy
- Troubleshooting
- Deployment tips
- Contributing
- License
- Acknowledgements

---

Project overview
This application takes an uploaded image of a traffic sign, preprocesses it, feeds it to a TensorFlow Keras model saved at `model/traffic_sign_model.h5`, and returns:
- A predicted traffic sign label and confidence
- Top 3 candidate classes with confidences
- A language-aware guidance message explaining safe actions
- A base64-encoded MP3 audio alert generated by gTTS
- A persisted copy of the uploaded image in `static/uploads` for history

The app UI (templates/index.html) offers a drag-and-drop uploader, language selector, results pane with audio controls, and a saved-history panel.

Features
- Image upload / drag-and-drop
- Prediction with model loaded from `model/traffic_sign_model.h5`
- Top-3 alternative predictions
- Language-specific safety guidance (text + speech)
- Persist uploaded images to `static/uploads/` with timestamps
- Endpoints to clear history and delete specific images
- Client-side UI that plays audio alerts (autoplay when allowed)

Project structure
(This is the relevant subset of the repo)
- Traffic sign/
  - app.py                       # Flask application (main server)
  - templates/
    - index.html                 # Frontend UI
  - static/
    - style.css                  # Styling
    - uploads/                   # Saved uploaded images (created at runtime)
  - model/
    - traffic_sign_model.h5      # Pre-trained TensorFlow Keras model (REQUIRED)
  - README.md                    # This file

Important files:
- `app.py` — main Flask app. Loads the model at startup, handles `/`, `/predict`, `/clear`, and `/delete_image/<filename>`.
- `model/traffic_sign_model.h5` — the trained Keras model file the app loads. If missing, predictions will return an error.
- `templates/index.html` — the single-page UI.
- `static/style.css` — styles and responsive layout.

Requirements
- Python 3.8+
- A CPU or GPU environment with appropriate TensorFlow installation
- Internet access for gTTS (text-to-speech requires network)
- Disk write permission for `static/uploads/`

Python package dependencies (example)
You can place these into a `requirements.txt` file:

```text
Flask>=2.0
tensorflow>=2.4
numpy
Pillow
gtts
werkzeug
```

Note:
- For smaller footprint or if GPU isn’t used, install the CPU-only TensorFlow wheel (e.g., `pip install tensorflow` will select CPU on many systems; on some, you may prefer `tensorflow-cpu`).
- gTTS requires network access because it uses Google TTS service.

Quick start (run locally)
1. Clone the repository:
   git clone https://github.com/aanisha0112/Traffic-sign.git
   cd Traffic-sign/"Traffic sign"

2. Create & activate a virtual environment (recommended):
   python -m venv venv
   On macOS/Linux:
     source venv/bin/activate
   On Windows:
     venv\Scripts\activate

3. Install dependencies:
   pip install -r requirements.txt
   (or individually: pip install Flask tensorflow numpy Pillow gtts werkzeug)

4. Ensure the trained model file exists:
   - Place your trained model at `model/traffic_sign_model.h5`.
   - The app expects the model to be a Keras `.h5` file compatible with `tf.keras.models.load_model`.

5. Create uploads folder (app will create it automatically, but ensure permissions are OK):
   mkdir -p static/uploads

6. Run the app:
   python app.py

7. Open your browser to:
   http://localhost:5000

API endpoints
- GET /  
  Serves the web UI (index.html).

- POST /predict  
  Accepts `multipart/form-data`:
  - file: (image file) — allowed extensions: png, jpg, jpeg, bmp, gif
  - language: (optional) language code (default: "en")

  Response JSON (success example):
  {
    "predicted_class": "Speed limit 50",
    "confidence": 0.9423,
    "guidance": "Reduce your speed to 50 kilometers per hour. Standard speed limit in built-up areas.",
    "top_predictions": [
      {"class": "Speed limit 50", "confidence": 0.9423, "guidance": "..."},
      {"class": "Speed limit 30", "confidence": 0.0312, "guidance": "..."},
      {"class": "Speed limit 20", "confidence": 0.0101, "guidance": "..."}
    ],
    "image_url": "/static/uploads/filename_20260107_123456.jpg",
    "image_filename": "filename_20260107_123456.jpg",
    "audio_data": "<base64-encoded-mp3>",
    "alert_message": "Speed limit 50. Reduce your speed to 50 kilometers per hour. Standard speed limit in built-up areas.",
    "timestamp": "2026-01-07 12:34:56",
    "language": "en"
  }

- POST /clear  
  Clears all files in `static/uploads/`.

- DELETE /delete_image/<filename>  
  Deletes a specific uploaded image from `static/uploads`.

How predictions work (server-side summary)
1. Image preprocessing:
   - App resizes the incoming image to 30x30 (see `preprocess_image`) and normalizes pixel values dividing by 255.
   - Adds a batch axis: shape (1, 30, 30, 3).

2. Model inference:
   - Uses `tf.keras.models.load_model('model/traffic_sign_model.h5')` at startup.
   - Predicts probabilities; chooses the argmax as `predicted_class`.
   - Also computes top-3 indices and returns their names and confidences.

3. Guidance + speech:
   - Each class in `app.py` contains a `name` and `guidance` dictionary keyed by language codes.
   - The server composes an alert message: "<predicted_class>. <guidance in chosen language>"
   - gTTS converts the alert message into MP3; the MP3 data is returned base64-encoded.

Supported languages (language codes in UI)
- en: English
- es: Spanish
- fr: French
- sa: Sanskrit
- pa: Punjabi
- hi: Hindi
- ja: Japanese
- zh: Chinese
- ta: Tamil
- ar: Arabic
- kn: Kannada

(These map to gTTS language codes defined in `app.py`. If you add a language, include its `gtts_lang` code and add guidance strings for that language in `classes` mapping.)

Model and classes
- The app expects classes numbered 0..N (the `classes` mapping is defined inside `app.py`).
- The current `classes` mapping in `app.py` contains human-readable names and language-specific guidance messages for many traffic sign types.
- Ensure your trained model's label indices match the `classes` mapping (index 0 in model should refer to class 0 in the mapping, etc.).

Training / Retraining the model (high-level)
If you need to train or retrain the model, here’s a roadmap:

1. Dataset
   - Common dataset: GTSRB (German Traffic Sign Recognition Benchmark) or any labeled traffic sign dataset. Ensure classes align with your `classes` mapping or update mapping to match labels.

2. Preprocessing
   - Resize input images to 30x30 (as the app uses 30x30 inputs).
   - Normalize pixel values to 0..1 (divide by 255).
   - Use one-hot labels for multi-class classification.

3. Model (example)
   - Use a convolutional neural network suitable for small images. Example layers:
     - Conv2D -> ReLU -> MaxPool -> Conv2D -> ReLU -> MaxPool -> Flatten -> Dense -> Softmax
   - Ensure output dimension equals number of classes.

4. Training
   - Use common callbacks: ModelCheckpoint, EarlyStopping, ReduceLROnPlateau.
   - Train to a validation split or using a held-out test set.

5. Save model
   - After training, save as `model/traffic_sign_model.h5`:
     model.save('model/traffic_sign_model.h5')

6. Validate
   - Load the saved model with `tf.keras.models.load_model` and check predictions on sample images.

Improving accuracy (tips)
- Data augmentation (rotation, translation, brightness, contrast) helps generalization.
- Use image normalization and standardization.
- Try deeper architectures or transfer learning (e.g., MobileNet with lower input resolution).
- Balance classes or use class weights if dataset is imbalanced.
- Fine-tune with a learning rate schedule and early stopping.

Security, privacy & limitations
- gTTS requires external network calls to Google; ensure privacy requirements are met before sending messages.
- Uploaded images are stored in `static/uploads` by default and are not private; clear them when necessary.
- The app does not implement authentication—avoid exposing to the public without adding access controls.
- The model is only as good as its training data; verify predictions before using in safety-critical systems.

Troubleshooting
- "Model not available" or model is None:
  - Ensure `model/traffic_sign_model.h5` exists and is compatible with your TensorFlow version.
  - Check app logs for exception details when `tf.keras.models.load_model()` runs.

- gTTS / audio problems:
  - gTTS needs internet to fetch audio from Google's service. No network = no audio.
  - If gTTS fails, the server logs an error and returns null `audio_data`.

- Upload errors / max size:
  - `app.config['MAX_CONTENT_LENGTH']` is set to 16 MB. Uploads larger than that will be rejected.

- Permission errors saving files:
  - Ensure your process has write permissions to `static/uploads`.

- Autoplay blocked in browser:
  - Many browsers block autoplay. The UI attempts to play the audio; user interaction may be required to allow playback.

Sample curl usage
Upload an image and request guidance in Kannada:
curl -X POST -F "file=@/path/to/sign.jpg" -F "language=kn" http://localhost:5000/predict

Deployment tips
- Use a production WSGI server (Gunicorn, uWSGI) behind a reverse proxy (Nginx).
- Disable Flask debug mode in production (set debug=False).
- Consider hosting the model separately (TF Serving) for scalability.
- Use HTTPS for any external deployment, especially when using gTTS or handling user uploads.

Docker (quick idea)
You can containerize the app by creating a Dockerfile that installs Python, copies the app, installs dependencies, and exposes port 5000. Remember to copy the model into the image or mount it at runtime.

Contributing
- Fixes, improvements, or language additions are welcome.
- If you retrain the model with a different label order, update the `classes` mapping in `app.py` to match new label indices.
- Add tests for endpoints and model loading if you extend the project.

License
- Add your preferred license (MIT, Apache 2.0, etc.) to the repo. The README does not impose a license.

Acknowledgements
- gTTS (Google Text-to-Speech)
- TensorFlow / Keras
- GTSRB and other traffic-sign datasets used for model training

Contact
- For questions about the repository, open an issue in the GitHub repo.

---

If you'd like, I can:
- Generate a sample `requirements.txt` and `Dockerfile`.
- Provide a sample training script for retraining a small CNN on GTSRB with TensorFlow.
- Add a `Procfile` or Gunicorn command for production deployment.
